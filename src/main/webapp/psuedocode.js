function pcodeToJs(code)
{
    var strings = code.match(/\".*?\"/g);
    if (strings == null) strings = [];
    code = code.toLowerCase();
    $.each(strings,function(){
       var re = this.toLowerCase();
       code = code.replace(re,this); 
    });        
   
    // fix any spaces between array names and elements
    code = editor.getValue().replace(/([a-zA-Z0-9]+)\s+\[/gi,"$1[");
   
    // kludge "until false"
    // This is generated by an empty repeat/until block in Blockly
    code = code.replace(/until false/g,"until infinite_loopxyzabc");
    // same for "while false"
    // Would be a while with no condition
    code = code.replace(/while false/g,"while waste_of_timexyzabc");
    // same for "is false"
    code = code.replace(/if \(false\)/g,"if waste_of_if_timexyzabc");
 
    // fix any references to functions that return values
    code = code.replace(/\bresultof (([a-z]|[A-Z]|[0-9]|_|,)+)/g," $1()");
    code = code.replace(/\(\)\(/g,"(");

    // kludge in random number keyword
    code = code.replace(/random\(([0-9]+?)\)/g,"Math.floor\(Math.random\(\)*\($1\+1)\)");

    var js = "";
    // split code up by return chars
    var codeLines = code.split("\n");    
    var statusLines = [];
    var simplereps = [];
    statusLines[codeLines.length - 1] = undefined;
    simplereps[codeLines.length - 1] = undefined;
    
    for (var i = 0; i < codeLines.length; i++)
    {
       var line = codeLines[i];
       line = line.trim();
       if (line.length == 0)
       {
           statusLines[i] = true;
           codeLines[i] = "//";
           continue;
       }
       if (!statusLines[i]) // line needs converting
       {
           line = doRegex(line,i);
           
           // replace any spaces between quotes with _
           //var quoteStrings = codeLines[i].match(/".*?"/g);
           //if (!quoteStrings) quoteStrings = [];
           //$.each(quoteStrings,function(){
           //   var underscored = this.replace(/\s/,"_");
           //   line = line.replace(this,underscored);
           //});           
           // split line into tokens
           var tokens = getTokens(line);
           
           //var tokens = line.replace("="," = ").split(/[^0-9A-Za-z_"=\+\-\*\/<>!\(\)]/).filter(function(x){ return (x != "") });
           // put spaces back into string tokens
           /*$.each(tokens,function(x,token){
               token = token.trim();
               if (token.slice(0,1) == '"' && token.slice(-1) == '"')
               {
                   token = token.replace("_"," ");
                   tokens[x] = token;
               }
           });          */
            
           // check for X times repetition
           if (tokens[tokens.length-1] == "times")
           {
               tokens.pop(); // strip times
               simplereps[i] = tokens.pop(); // should be number, strip and stash
               line = line.replace(/[0-9]+\s+times/g,"");
           }
           
           var keyword = tokens[0].toLowerCase();          
           if (keyword == "display" || keyword == "prompt")
           {
               if (tokens.length < 2) return ["error","You can't have a "+keyword.toUpperCase+" without something to show.",i];
               var value = "";
               for (var x = 1; x < tokens.length; x++) value += tokens[x];             
               line = 'println ('+value+');';
               codeLines[i] = line;
               statusLines[i] = true;
           }
           else if (keyword == "rem" || keyword == "//")
           {
               line = line.replace(/rem/,"").trim();
               codeLines[i] = "// "+line;
               statusLines[i] = true;
           }
           else if (keyword == "call")
           {
               if (tokens.length < 2) return ["error","You can't CALL a function without specifying the function name.",i];
               if (line.indexOf("(") == -1 && line.indexOf(")") == -1) line += "()";
               line = line.replace(/call/,"");
               codeLines[i] = line+";";
               statusLines[i] = true;
           }
           else if (keyword == "get")
           {
               if (tokens.length < 2) return ["error","You can't have a GET without a variable.",i];                   
               var varName = tokens[1];
               line = 'var '+varName+' = input(">");';
               // if we've ended up with
               // something.get(4) = input(">"); in our line, it's an array
               // needs to become
               // something.set(4,input(">"));
               // do a switcheroo
               var arrMatch = line.match(/\b(\w*?)\.get\(([0-9A-Za-z_\+\-\/\*]+),\s*(\d*)\) = input\("\>"\);/);
               if (arrMatch)
               {
                   line = arrMatch[1]+".set("+arrMatch[2]+',input(">"),'+arrMatch[3]+');';
               }
               codeLines[i] = line;
               statusLines[i] = true;
           }           
           else if (keyword == "for")
           {
               //line = line.toLowerCase();
               line = line.replace(/for/i,"");
               line = line.trim();
               var sides = line.split(/ to /i);
               if (sides.length != 2) return ["error","A FOR must have a TO."];
               if (sides[0].indexOf("=") == -1) return ["error","A FOR must include an equals sign."];
               if (sides[0].indexOf("==") == -1) sides[0] = sides[0].replace("=","==");
               var varName = sides[0].split("==")[0].trim();
               var startVal = sides[0].split("==")[1].trim();
               // look for the endfor
               var forOffset = 0;
               var foundFor = false;
               for (var x = i+1; x < codeLines.length; x++)
               {
                   var tempLine = codeLines[x];
                   var tempTokens = getTokens(tempLine);
                   tempLine = tempLine.trim();
                   if (tempLine.length == 0) continue;
                   var tempKeyword = tempTokens[0].toLowerCase();
                   if (tempKeyword == "for")
                   {
                       // found a nested if...
                       forOffset++;
                       continue;
                   }
                   if (tempKeyword == "endfor" && forOffset != 0)
                   {
                       // nested if terminated .. still not found ours yet though
                       forOffset--;
                       continue;
                   }
                   if (tempKeyword == "endfor" && forOffset == 0)
                   {
                       // ours! yay!
                       
                       var operator = " <= ";
                       if (startVal > parseInt(sides[1])) operator = ">=";   
                       
                       var step = 1;
                       
                       // check for step
                       if (tokens[tokens.length-2].toLowerCase() == "step")
                       {
                           step = tokens[tokens.length-1];
			   if (step < 0) operator = ">=";
                       }
                       
                       line = 'for (var '+varName+' = '+startVal+'; '+varName+operator+sides[1]+"; "+varName+"="+varName+"+"+step+") { // for "+i;
			line = line.replace(/step .*;/i,";");
                       codeLines[i] = line;
                       statusLines[i] = true;
                       // set endif
                       codeLines[x] = "} // endfor "+i
                       statusLines[x] = true;
                       foundFor = true;
                       break;
                   }                   
               }
               if (!foundFor) return ["error","This FOR doesn't appear to have a corresponding ENDFOR.",i];               
           }
           else if (keyword == "repeat")
           {
                // do nothing... we'll work backwards from the until...
           }           
           else if (keyword == "until")
           {
               if (tokens.length < 2) return ["error",keyword.toUpperCase()+" cannot be used on its own!",i];
               var condition = "";
               for (var x = 1; x < tokens.length; x++)
               {
                   if (tokens[x] == "=") tokens[x] = "==";
                   condition += " "+tokens[x]+" ";
               }
               if (condition.indexOf("==") == -1) condition = condition.replace("=","==");
               if (condition.indexOf("<>") == -1) condition = condition.replace("<>","!=");
               // look for the repeat...
               var ifOffset = 0;
               var foundRepeat = false;
               for (var x = i-1; x > -1; x--)
               {
                   var tempLine = codeLines[x];
                   var tempTokens = getTokens(tempLine);
                   tempLine = tempLine.trim();
                   if (tempLine.length == 0) continue;
                   var tempKeyword = tempTokens[0].toLowerCase();
                   if (tempKeyword == keyword)
                   {
                       // found another until
                       ifOffset++;
                       continue;
                   }
                   if (tempKeyword == "repeat" && ifOffset != 0)
                   {
                       // found a repeat.. still not found ours yet though
                       ifOffset--;
                       continue;
                   }
                   if (tempKeyword == "repeat" && ifOffset == 0)
                   {
                       // ours! yay!
                       line = '} while (!('+condition+')) // repeatUntil '+i;
                       codeLines[i] = line;
                       statusLines[i] = true;
                       // set do
                       codeLines[x] = "do { // repeatUntil "+i;
                       statusLines[x] = true;
                       foundIf = true;
                       break;
                   }                   
               }
               if (!foundIf) return ["error","This "+keyword.toUpperCase()+" doesn't appear to have a corresponding DO.",i];
           }
           else if (keyword == "function")
           {
           		if (tokens.length < 2) return ["error","FUNCTION must have a function name.",i];
           		if (tokens.length == 2) line += "()";
           		// look for the endfunction
               var ifOffset = 0;
               var foundIf = false;
               for (var x = i+1; x < codeLines.length; x++)
               {
                   var tempLine = codeLines[x];
                   var tempTokens = getTokens(tempLine);
                   tempLine = tempLine.trim();
                   if (tempLine.length == 0) continue;
                   var tempKeyword = tempTokens[0].toLowerCase();
                   if (tempKeyword == keyword)
                   {
                       // found a nested if...
                       ifOffset++;
                       continue;
                   }
                   if (tempKeyword == "end"+keyword && ifOffset != 0)
                   {
                       // nested if terminated .. still not found ours yet though
                       ifOffset--;
                       continue;
                   }
                   if (tempKeyword == "end"+keyword && ifOffset == 0)
                   {
                       // ours! yay!
                       line = line+' { // start'+keyword+' '+i;
                       codeLines[i] = line;
                       statusLines[i] = true;
                       // set endif
                       codeLines[x] = "} // end"+keyword+" "+i;
                       statusLines[x] = true;
                       foundIf = true;
                       break;
                   }                   
               }
               if (!foundIf) return ["error","This "+keyword.toUpperCase()+" doesn't appear to have a corresponding END"+keyword.toUpperCase()+".",i];
           }
           else if (keyword == "return")
           {
               codeLines[i] = line+";";
               statusLines[i] = true;
           }
           else if (keyword == "if" || keyword == "while")
           {
               if (tokens.length < 2) return ["error",keyword.toUpperCase()+" cannot be used on its own!",i];
               var condition = "";
               for (var x = 1; x < tokens.length; x++)
               {
                   if (tokens[x] == "=") tokens[x] = "==";
                   condition += " "+tokens[x]+" ";
               }
               if (condition.indexOf("==") == -1) condition = condition.replace("=","==");
               if (condition.indexOf("<>") != -1) condition = condition.replace("<>","!=");               
               
               // look for the endif
               var ifOffset = 0;
               var foundIf = false;
               for (var x = i+1; x < codeLines.length; x++)
               {
                   var tempLine = codeLines[x];
                   var tempTokens = getTokens(tempLine);
                   tempLine = tempLine.trim();
                   if (tempLine.length == 0) continue;
                   var tempKeyword = tempTokens[0].toLowerCase();
                   if (tempKeyword == keyword)
                   {
                       // found a nested if...
                       ifOffset++;
                       continue;
                   }
                   if (tempKeyword == "end"+keyword && ifOffset != 0)
                   {
                       // nested if terminated .. still not found ours yet though
                       ifOffset--;
                       continue;
                   }
                   if (tempKeyword == "end"+keyword && ifOffset == 0)
                   {
                       // ours! yay!
                       line = keyword+' ('+condition+') { // start'+keyword+' '+i;
                       codeLines[i] = line;
                       statusLines[i] = true;
                       // set endif
                       codeLines[x] = "} // end"+keyword+" "+i;
                       statusLines[x] = true;
                       foundIf = true;
                       break;
                   }                   
               }
               if (!foundIf) return ["error","This "+keyword.toUpperCase()+" doesn't appear to have a corresponding END"+keyword.toUpperCase()+".",i];
           }
           else if (keyword == "else")
           {
               line = "} else {";
               codeLines[i] = line;
               statusLines[i] = true;
           }
           else if (keyword == "elseif")
           {
               
           }
           else if (keyword == "declare")
           {   
               var x = tokens[1].split(".");
               var varname = x[0];
               var length = x[1].split("(")[1];
               length = length.split(",")[0];               
               line = "var "+varname+" = new parent.FixedArray("+length+");";
               codeLines[i] = line;
               statusLines[i] = true;
           }
           // carol commands
           else if (keyword == "move")
           {
               codeLines[i] = "move();";
               statusLines[i] = true;
           }
           else if (keyword == "turnleft")
           {
               codeLines[i] = "turnLeft();";
               statusLines[i] = true;
           }
           else if (keyword == "pickup")
           {
               codeLines[i] = "pickUp();";
               statusLines[i] = true;
           }
           else if (keyword == "putdown")
           {
               codeLines[i] = "putDown();"
               statusLines[i] = true;
           }
           else if (keyword == "setdelay")
           {
               codeLines[i] = "setDelay("+tokens[1]+");"
               statusLines[i] = true;
           }
           else if (keyword == "printbasket")
           {
               codeLines[i] = "printBacket();";
               statusLines[i] = true;
           }
           
           else if (line.indexOf(".set(") != -1)
           {
               // assigning to array
               // will have started out as
               // something[2] = "whatever"
               // set something[2] = "whatever"
               // Gets converted to 
               // something.set(2,"whatever") in early regexes
               // Only need to remove
               // possible prefixing set
               line = line.replace(/^set/,"").trim();
               codeLines[i] = line;
               statusLines[i] = true;
           }
           else 
           {   
               if (keyword != "set")
               {
                   // try adding a set in front... see if it makes sense
                   tokens.unshift("set");
               }
               if (tokens.length < 2)
               {
                   return ["error","You can't have a SET without a variable.",i];                                  
               }
               else
               {
                    var varName = tokens[1];
                    if (tokens.length < 3 || $.inArray(tokens[2],["=","+=","-=","*=","/="]) == -1)
                    {
                        if(line.indexOf("set") == -1)
                        {
                            return ["error","I can't make any sense whatsoever of this line :-(",i];
                        }
                        // otherwise
                        return ["error","You can't have a SET without a operator",i];
                    }
                    var operator = tokens[2];
                    if (tokens.length < 4) return ["error","You can't have a SET without a value to actually set.",i];               

                    // if the last but one token is "as" then they've declared a type
                    // TODO: something about it! :-)
                    if (tokens[tokens.length-2] == "as")
                    {
                        tokens.pop();
                        tokens.pop();
                    }
                    
                    if (tokens[3] == "call")
                    {
                        tokens[3] = "";
                        if (tokens.length == 5)
                        {
                            tokens[5] += "()"; // call function with no params
                        }
                    }

                    var value = "";
                    for (var x = 3; x < tokens.length; x++) value += tokens[x];               
                    // otherwise...!
                    line = 'var '+varName+' '+operator+' '+value+";";
                    // don't declare var if += etc being used
                    if (operator != "=") line = line.replace("var ","");
                    codeLines[i] = line;
                    statusLines[i] = true;
               }
           }
       }
    }        
    
    // second pass - elseifs
    for (var i = 0; i < codeLines.length; i++)
    {
        var line = codeLines[i];
        line = doRegex(line,i);
        if (!statusLines[i])
        {
            var tokens = getTokens(line);
            if (tokens == null) tokens = [];
            if (tokens[0] == "elseif")
            {
               if (tokens.length < 2) return ["error","Else if must have a condition",i];
               var condition = "";
               for (var x = 1; x < tokens.length; x++)
               {
                   if (tokens[x] == "=") tokens[x] = "==";
                   condition += " "+tokens[x]+" ";
               }
               if (condition.indexOf("==") == -1) condition = condition.replace("=","==");
               if (condition.indexOf("<>") != -1) condition = condition.replace("<>","!=");
               
               line = "} else if ("+condition+") {";
               codeLines[i] = line;
               statusLines[i] = true;               
            }
        }
    }    
    
    // final pass - repetitions
    for (var i = 0; i < codeLines.length; i++)
    {
        var line = codeLines[i];
        var varname = "simplerep"+Math.random().toString(16).slice(2);
        if (simplereps[i]) codeLines[i] = "for (var "+varname+" = 0; "+varname+" < "+simplereps[i]+"; "+varname+"++) { "+line+" }";
    }    
    
    $.each(codeLines,function(i,line){
        line = line.trim();
        if (line != "") js += line+"\n";
    });    
    
    js = js.replace(/<==/g,"<=");
    js = js.replace(/>==/g,">=");
    
    // carol functions
    
    js = js.replace(/isblocked/g,"isBlocked()");
    js = js.replace(/isnotblocked/g,"isNotBlocked()");
    js = js.replace(/ispickupvisible/g,"isPickupVisible()");
    js = js.replace(/distancetopickup/g,"distanceToPickup()");
    js = js.replace(/notatgoal/g,"notAtGoal()");
    js = js.replace(/atgoal/g,"atGoal()");
    
    
    try { console.log(js_beautify(js)); } catch (e) {}
    
    return js;
}

function runpcode(code)
{
    var oldcode = code;
    code = pcodeToJs(code);   
        
    if (code[0] != "error")
    {
        hiddenRun(code);
        LOGrun(oldcode);
    }
    else
    {
        displayPcodeCompError(code);
    }
}

function displayPcodeCompError(errorArr)
{
    // need to wipe out the outputframe jframe...
    $(outputframe.window.document.body).empty();    
    var errorText = errorArr[1];
    var errorLine = errorArr[2];
    $(outputframe.window.document.body).append('<span style="font-family: monospace; color: red; font-weight: bolder">Error detected: '+errorText+'<br/>Error at or around line number '+(errorLine+1)+'</span>.');    
    editor.focus(); 
    editor.setCursor(errorLine);
    //editor.setLineClass(errorLine,"error");
    editor.addLineClass(errorLine,"background","error");
}

function getTokens(line)
{
    return line.match(/[0-9A-Za-z_]+\.set\(.*\)|,|[0-9A-Za-z_]+\.get\(.*\)|[0-9A-Za-z_\.]+|\-[0-9]+|\+\=|\-\=|\/\=|\*\=|%|\<\=|\>\=|\<\>|\!\=|\!|\>|\<|\+|\-|\*|\/|".*?"|\=|\|\||&&|\(|\)/gi);
}

function FixedArray(length)
{
    this.length = length;
    var actualArray = new Array(length);
   
    this.get = function(index,lineno) {
        lineno++;
        if (index >= length) throw new Error("Index exceeds the array length at line "+lineno);
        if (index < 0) throw new Error("Invalid index at line "+lineno);
        return actualArray[index];
    }
    
    this.set = function(index,what,lineno) {
        lineno++;
        if (index >= length) throw new Error("Index exceeds the array length at line "+lineno);
        if (index < 0) throw new Error("Invalid index at line "+lineno);
        actualArray[index] = what;
    }
}

function doRegex(line,i)
{
    //line = line.replace(/\bor\b/gi," || ");
    // this is the best regex I've ever seen. I just wish I understood
    // it
    line = line.replace(/(\bor\b)(?=(?:[^"]|"[^"]*")*$)/gi," || ");
    //line = line.replace(/\band\b/gi," && ");
    // truly brilliant.
    line = line.replace(/(\band\b)(?=(?:[^"]|"[^"]*")*$)/gi," && ");
    // awesome
    //line = line.replace(/\bnot\b/gi,"!");
    line = line.replace(/(\bnot\b)(?=(?:[^"]|"[^"]*")*$)/gi,"!")

    line = line.replace(/\bmod\b/gi," % ");
    line = line.replace(/<>/g,"!=");
    line = line.replace(/==/g,"=");
    line = line.replace(/\b(\w*)\b\[([0-9A-Za-z_\+\-\/\*]+)\]\s*\=(.*)/g,"$1.set($2,$3,"+i+");");
    line = line.replace(/\b(\w*)\b\[([0-9A-Za-z_\+\-\/\*]+)\]/g,"$1.get($2,"+i+")");
    line = line.replace(/\belse\s*if\b/gi,"elseif");
    return line;
}
