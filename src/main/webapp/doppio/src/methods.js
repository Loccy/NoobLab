// Generated by CoffeeScript 1.3.3
(function() {
  var AbstractMethodField, ReturnException, attributes, c2t, carr2type, debug_vars, java_throw, logging, native_methods, natives, opcodes, root, runtime, str2type, trace, trapped_methods, types, util, vtrace, _, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  _ = require('../vendor/_.js');

  util = require('./util');

  opcodes = require('./opcodes');

  attributes = require('./attributes');

  types = require('./types');

  natives = require('./natives');

  runtime = require('./runtime');

  logging = require('./logging');

  vtrace = logging.vtrace, trace = logging.trace, debug_vars = logging.debug_vars;

  _ref = require('./exceptions'), java_throw = _ref.java_throw, ReturnException = _ref.ReturnException;

  str2type = types.str2type, carr2type = types.carr2type, c2t = types.c2t;

  native_methods = natives.native_methods, trapped_methods = natives.trapped_methods;

  "use strict";


  root = typeof exports !== "undefined" && exports !== null ? exports : this.methods = {};

  AbstractMethodField = (function() {

    function AbstractMethodField(class_type) {
      this.class_type = class_type;
    }

    AbstractMethodField.prototype.parse = function(bytes_array, constant_pool, idx) {
      this.idx = idx;
      this.access_byte = bytes_array.get_uint(2);
      this.access_flags = util.parse_flags(this.access_byte);
      this.name = constant_pool.get(bytes_array.get_uint(2)).value;
      this.raw_descriptor = constant_pool.get(bytes_array.get_uint(2)).value;
      this.parse_descriptor(this.raw_descriptor);
      return this.attrs = attributes.make_attributes(bytes_array, constant_pool);
    };

    return AbstractMethodField;

  })();

  root.Field = (function(_super) {

    __extends(Field, _super);

    function Field() {
      return Field.__super__.constructor.apply(this, arguments);
    }

    Field.prototype.parse_descriptor = function(raw_descriptor) {
      return this.type = str2type(raw_descriptor);
    };

    Field.prototype.reflector = function(rs) {
      var sig, _ref1;
      sig = (_ref1 = _.find(this.attrs, function(a) {
        return a.name === "Signature";
      })) != null ? _ref1.sig : void 0;
      return rs.init_object('java/lang/reflect/Field', {
        'java/lang/reflect/Field/clazz': rs.jclass_obj(this.class_type),
        'java/lang/reflect/Field/name': rs.init_string(this.name, true),
        'java/lang/reflect/Field/type': rs.jclass_obj(this.type),
        'java/lang/reflect/Field/modifiers': this.access_byte,
        'java/lang/reflect/Field/slot': this.idx,
        'java/lang/reflect/Field/signature': sig != null ? rs.init_string(sig) : null
      });
    };

    return Field;

  })(AbstractMethodField);

  root.Method = (function(_super) {
    var padding;

    __extends(Method, _super);

    function Method() {
      return Method.__super__.constructor.apply(this, arguments);
    }

    Method.prototype.parse_descriptor = function(raw_descriptor) {
      var field, p, param_carr, param_str, return_str, __, _i, _len, _ref1, _ref2, _ref3;
      _ref1 = /\(([^)]*)\)(.*)/.exec(raw_descriptor), __ = _ref1[0], param_str = _ref1[1], return_str = _ref1[2];
      param_carr = param_str.split('');
      this.param_types = ((function() {
        var _results;
        _results = [];
        while ((field = carr2type(param_carr))) {
          _results.push(field);
        }
        return _results;
      })());
      this.param_bytes = 0;
      _ref2 = this.param_types;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        p = _ref2[_i];
        this.param_bytes += (_ref3 = p.toString()) === 'D' || _ref3 === 'J' ? 2 : 1;
      }
      if (!this.access_flags["static"]) {
        this.param_bytes++;
      }
      this.num_args = this.param_types.length;
      if (!this.access_flags["static"]) {
        this.num_args++;
      }
      return this.return_type = str2type(return_str);
    };

    Method.prototype.full_signature = function() {
      return "" + (this.class_type.toClassString()) + "::" + this.name + this.raw_descriptor;
    };

    Method.prototype.parse = function(bytes_array, constant_pool, idx) {
      var c, sig,
        _this = this;
      Method.__super__.parse.call(this, bytes_array, constant_pool, idx);
      sig = this.full_signature();
      if ((c = trapped_methods[sig]) != null) {
        this.code = c;
        return this.access_flags["native"] = true;
      } else if (this.access_flags["native"]) {
        if ((c = native_methods[sig]) != null) {
          return this.code = c;
        } else if (typeof UNSAFE !== "undefined" && UNSAFE !== null) {
          return this.code = null;
        } else {
          return this.code = function(rs) {
            if (!(sig.indexOf('::registerNatives()V', 1) >= 0 || sig.indexOf('::initIDs()V', 1) >= 0)) {
              return java_throw(rs, 'java/lang/Error', "native method NYI: " + sig);
            }
          };
        }
      } else {
        this.has_bytecode = true;
        return this.code = _.find(this.attrs, function(a) {
          return a.name === 'Code';
        });
      }
    };

    Method.prototype.reflector = function(rs, is_constructor) {
      var adefs, anns, e, exceptions, f, obj, sig, typestr, _ref1, _ref2, _ref3, _ref4, _ref5;
      if (is_constructor == null) {
        is_constructor = false;
      }
      typestr = is_constructor ? 'java/lang/reflect/Constructor' : 'java/lang/reflect/Method';
      exceptions = (_ref1 = (_ref2 = _.find(this.attrs, function(a) {
        return a.name === 'Exceptions';
      })) != null ? _ref2.exceptions : void 0) != null ? _ref1 : [];
      anns = (_ref3 = _.find(this.attrs, function(a) {
        return a.name === 'RuntimeVisibleAnnotations';
      })) != null ? _ref3.raw_bytes : void 0;
      adefs = (_ref4 = _.find(this.attrs, function(a) {
        return a.name === 'AnnotationDefault';
      })) != null ? _ref4.raw_bytes : void 0;
      sig = (_ref5 = _.find(this.attrs, function(a) {
        return a.name === 'Signature';
      })) != null ? _ref5.sig : void 0;
      obj = {};
      obj[typestr + '/clazz'] = rs.jclass_obj(this.class_type);
      obj[typestr + '/name'] = rs.init_string(this.name, true);
      obj[typestr + '/parameterTypes'] = rs.init_array("[Ljava/lang/Class;", (function() {
        var _i, _len, _ref6, _results;
        _ref6 = this.param_types;
        _results = [];
        for (_i = 0, _len = _ref6.length; _i < _len; _i++) {
          f = _ref6[_i];
          _results.push(rs.jclass_obj(f));
        }
        return _results;
      }).call(this));
      obj[typestr + '/returnType'] = rs.jclass_obj(this.return_type);
      obj[typestr + '/exceptionTypes'] = rs.init_array("[Ljava/lang/Class;", (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = exceptions.length; _i < _len; _i++) {
          e = exceptions[_i];
          _results.push(rs.jclass_obj(c2t(e)));
        }
        return _results;
      })());
      obj[typestr + '/modifiers'] = this.access_byte;
      obj[typestr + '/slot'] = this.idx;
      obj[typestr + '/signature'] = sig != null ? rs.init_string(sig) : null;
      obj[typestr + '/annotations'] = anns != null ? rs.init_array('[B', anns) : null;
      obj[typestr + '/annotationDefault'] = adefs != null ? rs.init_array('[B', adefs) : null;
      return rs.init_object(typestr, obj);
    };

    Method.prototype.take_params = function(caller_stack) {
      var params, start;
      start = caller_stack.length - this.param_bytes;
      params = caller_stack.slice(start);
      caller_stack.length -= this.param_bytes;
      return params;
    };

    (typeof RELEASE !== "undefined" && RELEASE !== null) || (padding = '');

    Method.prototype.convert_params = function(rs, params) {
      var converted_params, p, param_idx, _i, _len, _ref1, _ref2;
      converted_params = [rs];
      param_idx = 0;
      if (!this.access_flags["static"]) {
        converted_params.push(params[0]);
        param_idx = 1;
      }
      _ref1 = this.param_types;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        p = _ref1[_i];
        converted_params.push(params[param_idx]);
        param_idx += ((_ref2 = p.toString()) === 'J' || _ref2 === 'D') ? 2 : 1;
      }
      return converted_params;
    };

    Method.prototype.run_manually = function(func, rs, converted_params) {
      var ret_type, rv;
      trace("entering native method " + (this.full_signature()));
      try {
        rv = func.apply(null, converted_params);
      } catch (e) {
        if (e === ReturnException) {
          return;
        }
        throw e;
      }
      rs.meta_stack().pop();
      ret_type = this.return_type.toString();
      if (ret_type !== 'V') {
        if (ret_type === 'Z') {
          rs.push(rv + 0);
        } else {
          rs.push(rv);
        }
        if (ret_type === 'J' || ret_type === 'D') {
          return rs.push(null);
        }
      }
    };

    Method.prototype.run_bytecode = function(rs) {
      try {
        return this.bytecode_loop(rs);
      } catch (e) {
        if (e === ReturnException) {
          return;
        }
        if (!(typeof e.method_catch_handler === "function" ? e.method_catch_handler(rs, this, true) : void 0)) {
          throw e;
        }
        return this.run_bytecode(rs);
      }
    };

    Method.prototype.bytecode_loop = function(rs) {
      var annotation, cf, code, op, pc;
      trace("entering method " + (this.full_signature()));
      code = this.code.opcodes;
      cf = rs.curr_frame();
      while (true) {
        op = code[cf.pc];
        if (!((typeof RELEASE !== "undefined" && RELEASE !== null) || logging.log_level < logging.STRACE)) {
          pc = cf.pc;
          if (!op) {
            throw "" + this.name + ":" + pc + " => (null)";
          }
          vtrace("" + padding + "stack: [" + (debug_vars(cf.stack)) + "], local: [" + (debug_vars(cf.locals)) + "]");
          annotation = op.annotate(pc, rs.class_lookup(this.class_type).constant_pool);
          vtrace(("" + padding + (this.class_type.toClassString()) + "::" + this.name + ":" + pc + " => " + op.name) + annotation);
        }
        if ((op.execute(rs)) !== false) {
          cf.pc += 1 + op.byte_count;
        }
      }
    };

    Method.prototype.setup_stack = function(runtime_state) {
      var c_params, caller_stack, ms, params, sf,
        _this = this;
      ms = runtime_state.meta_stack();
      caller_stack = runtime_state.curr_frame().stack;
      params = this.take_params(caller_stack);
      if (this.access_flags["native"]) {
        if (this.code != null) {
          ms.push(sf = new runtime.StackFrame(this, [], []));
          c_params = this.convert_params(runtime_state, params);
          sf.runner = function() {
            return _this.run_manually(_this.code, runtime_state, c_params);
          };
          return sf;
        }
        return;
      }
      if (this.access_flags.abstract) {
        java_throw(runtime_state, 'java/lang/Error', "called abstract method: " + (this.full_signature()));
      }
      ms.push(sf = new runtime.StackFrame(this, params, []));
      if (this.code.run_stamp < runtime_state.run_stamp) {
        this.code.run_stamp = runtime_state.run_stamp;
        this.code.parse_code();
      }
      sf.runner = function() {
        return _this.run_bytecode(runtime_state);
      };
      return sf;
    };

    return Method;

  })(AbstractMethodField);

}).call(this);
